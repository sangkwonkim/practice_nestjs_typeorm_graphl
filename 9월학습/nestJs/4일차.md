Custom providers

DI fundamentals
Dependency injection은 자신의 코드에서 명령적으로 수행하는 대신 instantiation of dependencies를 IoC 컨테이너(이 경우에는 NestJS 런타임 시스템)에 위임하는 IoC(inversion of control) 기술임.
먼저, provider를 정의하는 데, @Injectable() decorator를 사용해서 service class를 provider로 표시함

import { Injectable } from '@nestjs/common';
import { User } from './entity/user';

@Injectable()
export class UsersService {
  private readonly users: User[] = [];

  findAll(): User[] {
    return this.users;
  }
}

그런 다음 Nest가 controller class에 provider를 삽입함.

.. 중략 user.controller

@Controller('users')
export class UsersController {
  constructor(private usersService: UsersService) {}

  @Get()
  async findAll(): Promise<User[]> {
    return this.usersService.findAll();
  }
}

Nest IoC 컨테이너에 provider 등록



app.module.ts

.. 중략

@Module({
  controllers: [UserController],
  providers: [UserService],
})
export class AppModule {}

이러한 프로세스에서는 다음과 같은 일들이 발생함

먼저, service.ts에서는 @Injectable() decorator는 service class를 Nest IoC container에서 관리할 수 있는 class로 선언함
다음으로, controller.ts에서는 controller는 constructor 주입을 통해 service 토큰에 대한 종속성을 선언함
constructor(private usersService: UsersService) {}
마지막으로, app.module.ts에서, 토큰 service를 service.ts 파일의 class service와 연관시킴(이를 등록이라고도 함).

Nest IoC 컨테이너가 Controller를 인스턴스화할 때 먼저 모든 종속성을 찾음(간단하게 설명한다면!). Service 종속성을 찾으면 등록 단계(마지막 단계)에 따라 Service 클래스를 반환하는 Service 토큰에 대해 조회함. SINGLETON 범위(기본 동작)를 가정하면 Nest는 Service의 인스턴스를 만들고 캐시한 후 반환하거나 이미 캐시된 경우 기존 인스턴스를 반환함.


Standard providers
@Module() 데코레이터에 대해 자세히 살펴보겠습니다. app.module에서는 다음과 같이 @Module() decorator를 사용함

@Module({
  controllers: [Controller],
  providers: [Service],
})

providers속성은 providers의 배열을 사용 함. 지금까지 클래스 이름 목록을 통해 해당 provider를 제공했지만, 사실, providers: [Service]은 보다 완전한 구문을 위한 축약형임

providers: [
  {
    provide: Service,
    useClass: Service,
  },
];

여기에서 우리는 토큰 Service을 Service 클래스와 명확하게 연관시키고 있음. 토큰이 동일한 이름의 클래스 인스턴스를 요청하는 상황에 맞춰 축약할 수 있음.


Custom providers
Nest가 class를 인스턴스화(또는 캐시된 인스턴스를 반환)하는 대신 사용자 정의 인스턴스를 만드려는 경우
두 번째 종속성에서 기존 클래스를 다시 사용하려는 경우
테스트를 위해 모의 버전으로 클래스를 재정의하려는 경우

Nest를 사용하면 이러한 경우를 처리하기 위해 사용자 지정 공급자를 정의할 수 있음

HINT
종속성 해결에 문제가 있는 경우 NEST_DEBUG환경 변수를 설정하고 시작하는 동안 추가 종속성 해결 로그를 얻을 수 있습니다.

Value providers: useValue
useValue는 상수 값을 주입하거나 외부 라이브러리를 Nest 컨테이너에 넣거나 실제 구현을 모의 object로 바꾸는 데 유용함. 테스트 목적으로 Nest가 모의 서비스를 사용하길 원할 경우,

import { Service } from './.service';

const mockService = {
  /* mock implementation
  ...
  */
};

@Module({
  imports: [Module],
  providers: [
    {
      provide: Service,
      useValue: mockService,
    },
  ],
})
export class AppModule {}

이 예에서 Service 토큰은 모의 Service 모의 object로 분해됨. useValue에는 값이 필요한데, 이 경우 대체 중인 Service 클래스와 동일한 인터페이스를 가진 리터럴 object임. 
TypeScript의 구조적인 타이핑으로 인해 리터럴 객체나 새로 인스턴스화된 클래스 인스턴스를 포함하여 호환되는 인터페이스가 있는 모든 객체를 사용할 수 있음.