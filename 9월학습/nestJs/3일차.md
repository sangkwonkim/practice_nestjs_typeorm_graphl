Custom route decorators

Nest는 decorators라고 불리는 language feature를 중심으로 만들어짐.

ES2016 decorator는 함수를 반환하고 target, name 및 property 설명자를 인수로 사용할 수 있는 표현식임. decorator에 @ 문자를 붙이고 이것을 꾸미려고 하는 것의 맨 위에 놓음으로써 적용 가능함. Decorators는 class, method 또는 property에 대해 정의할 수 있음.

Param decorators
Nest는 HTTP route handlers와 함께 사용할 수 있는 유용한 param decorators 집합을 제공함. 
decorators 및 그것들이 나타내는 일반 Express(또는 Fastify) 객체의 목록임.

@Request(), @Req()	        req
@Response(), @Res()	        res
@Next()	                    next
@Session()	                req.session
@Param(param?: string)	    req.params / req.params[param]
@Body(param?: string)	    req.body / req.body[param]
@Query(param?: string)	    req.query / req.query[param]
@Headers(param?: string)	req.headers / req.headers[param]
@Ip()	                    req.ip
@HostParam()	            req.hosts


node.js는 properties을 request object에 연결하는 것이 일반이며 다음과 같은 코드를 사용하여 각 route handler에서 수동으로 추출할 수 있음
const user = req.user;

이러한 코드를 @User decorator로 만들 수 있음

import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const User = createParamDecorator(
  (data: unknown, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    return request.user;
  },
);

@Get()
async findOne(@User() user: UserEntity) {
  console.log(user);
}


Passing data#
When the behavior of your decorator depends on some conditions, you can use the data parameter to pass an argument to the decorator's factory function. One use case for this is a custom decorator that extracts properties from the request object by key. Let's assume, for example, that our authentication layer validates requests and attaches a user entity to the request object. The user entity for an authenticated request might look like:


